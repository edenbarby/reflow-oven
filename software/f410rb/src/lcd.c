#include "stm32f4xx_ll_bus.h"
#include "stm32f4xx_ll_gpio.h"
#include "stm32f4xx_ll_spi.h"
#include "stm32f4xx_ll_utils.h"

#include "lcd.h"


/* LCD 10168 interface. */
#define LCD_PORT     GPIOA
#define LCD_PIN_CS   LL_GPIO_PIN_4 // SPI1_NSS
#define LCD_PIN_SCLK LL_GPIO_PIN_5 // SPI1_SCK
#define LCD_PIN_MISO LL_GPIO_PIN_6 // SPI1_MISO
#define LCD_PIN_MOSI LL_GPIO_PIN_7 // SPI1_MOSI
#define LCD_PIN_RST  LL_GPIO_PIN_8 // ~RESET
#define LCD_PIN_MODE LL_GPIO_PIN_9 // 0 == CMD / 1 == DATA

/* Instruction Set */
#define LCD_FCNST     0x20
#define LCD_FCNST_EXT 0x01
#define LCD_FCNST_VRT 0x02
#define LCD_FCNST_PWR 0x04
/* Extended instruction set . */
#define LCD_DISPC     0x08
#define LCD_DISPC_CLR 0x00
#define LCD_DISPC_SET 0x01
#define LCD_DISPC_NRM 0x04
#define LCD_DISPC_INV 0x05
#define LCD_ADDRY     0x40
#define LCD_ADDRY_MSK 0x07
#define LCD_ADDRX     0x80
#define LCD_ADDRX_MSK 0x7F
/* Basic instruction set. */
#define LCD_TMPCF     0x04
#define LCD_TMPCF_MSK 0x03
#define LCD_BIASS     0x10
#define LCD_BIASS_MSK 0x07
#define LCD_VOPST     0x80
#define LCD_VOPST_MSK 0x7F

#define LCD_WIDTH         84
#define LCD_HEIGHT        48
#define LCD_FRAME_LENGTH 504 // (LCD_WIDTH * LCD_HEIGHT / 8)


/* BYTE REVERSING LOOKUP TABLE BLACK MAGIC ************************************/
#define R2(n)    n ,    n + 2*64 ,    n + 1*64 ,    n + 3*64
#define R4(n) R2(n), R2(n + 2*16), R2(n + 1*16), R2(n + 3*16)
#define R6(n) R4(n), R4(n + 2* 4), R4(n + 1* 4), R4(n + 3* 4)
uint8_t byte_reverse[256] = {R6(0), R6(2), R6(1), R6(3)};
/******************************************************************************/



enum LCD_MODE {
    LCD_MODE_CMD  = 0,
    LCD_MODE_DATA = 1
};


/* Font table:
This table contains the hex values that represent pixels for a
font that is 5 pixels wide and 8 pixels high. Each byte in a row
represents one, 8-pixel, vertical column of a character. 5 bytes
per character. */
static const uint8_t charset[96][5] = {
    // First 32 characters (0x00-0x19) are ignored. These are
    // non-displayable, control characters.
     {0x00, 0x00, 0x00, 0x00, 0x00} // 0x20
    ,{0x00, 0x00, 0x5f, 0x00, 0x00} // 0x21 !
    ,{0x00, 0x07, 0x00, 0x07, 0x00} // 0x22 "
    ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 0x23 #
    ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 0x24 $
    ,{0x23, 0x13, 0x08, 0x64, 0x62} // 0x25 %
    ,{0x36, 0x49, 0x55, 0x22, 0x50} // 0x26 &
    ,{0x00, 0x05, 0x03, 0x00, 0x00} // 0x27 '
    ,{0x00, 0x1c, 0x22, 0x41, 0x00} // 0x28 (
    ,{0x00, 0x41, 0x22, 0x1c, 0x00} // 0x29 )
    ,{0x14, 0x08, 0x3e, 0x08, 0x14} // 0x2a *
    ,{0x08, 0x08, 0x3e, 0x08, 0x08} // 0x2b +
    ,{0x00, 0x50, 0x30, 0x00, 0x00} // 0x2c ,
    ,{0x08, 0x08, 0x08, 0x08, 0x08} // 0x2d -
    ,{0x00, 0x60, 0x60, 0x00, 0x00} // 0x2e .
    ,{0x20, 0x10, 0x08, 0x04, 0x02} // 0x2f /
    ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 0x30 0
    ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 0x31 1
    ,{0x42, 0x61, 0x51, 0x49, 0x46} // 0x32 2
    ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 0x33 3
    ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 0x34 4
    ,{0x27, 0x45, 0x45, 0x45, 0x39} // 0x35 5
    ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 0x36 6
    ,{0x01, 0x71, 0x09, 0x05, 0x03} // 0x37 7
    ,{0x36, 0x49, 0x49, 0x49, 0x36} // 0x38 8
    ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 0x39 9
    ,{0x00, 0x36, 0x36, 0x00, 0x00} // 0x3a :
    ,{0x00, 0x56, 0x36, 0x00, 0x00} // 0x3b ;
    ,{0x08, 0x14, 0x22, 0x41, 0x00} // 0x3c <
    ,{0x14, 0x14, 0x14, 0x14, 0x14} // 0x3d =
    ,{0x00, 0x41, 0x22, 0x14, 0x08} // 0x3e >
    ,{0x02, 0x01, 0x51, 0x09, 0x06} // 0x3f ?
    ,{0x32, 0x49, 0x79, 0x41, 0x3e} // 0x40 @
    ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 0x41 A
    ,{0x7f, 0x49, 0x49, 0x49, 0x36} // 0x42 B
    ,{0x3e, 0x41, 0x41, 0x41, 0x22} // 0x43 C
    ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 0x44 D
    ,{0x7f, 0x49, 0x49, 0x49, 0x41} // 0x45 E
    ,{0x7f, 0x09, 0x09, 0x09, 0x01} // 0x46 F
    ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 0x47 G
    ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 0x48 H
    ,{0x00, 0x41, 0x7f, 0x41, 0x00} // 0x49 I
    ,{0x20, 0x40, 0x41, 0x3f, 0x01} // 0x4a J
    ,{0x7f, 0x08, 0x14, 0x22, 0x41} // 0x4b K
    ,{0x7f, 0x40, 0x40, 0x40, 0x40} // 0x4c L
    ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 0x4d M
    ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 0x4e N
    ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 0x4f O
    ,{0x7f, 0x09, 0x09, 0x09, 0x06} // 0x50 P
    ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 0x51 Q
    ,{0x7f, 0x09, 0x19, 0x29, 0x46} // 0x52 R
    ,{0x46, 0x49, 0x49, 0x49, 0x31} // 0x53 S
    ,{0x01, 0x01, 0x7f, 0x01, 0x01} // 0x54 T
    ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 0x55 U
    ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 0x56 V
    ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 0x57 W
    ,{0x63, 0x14, 0x08, 0x14, 0x63} // 0x58 X
    ,{0x07, 0x08, 0x70, 0x08, 0x07} // 0x59 Y
    ,{0x61, 0x51, 0x49, 0x45, 0x43} // 0x5a Z
    ,{0x00, 0x7f, 0x41, 0x41, 0x00} // 0x5b [
    ,{0x02, 0x04, 0x08, 0x10, 0x20} // 0x5c \ (keep this to escape the backslash)
    ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
    ,{0x04, 0x02, 0x01, 0x02, 0x04} // 0x5e ^
    ,{0x40, 0x40, 0x40, 0x40, 0x40} // 0x5f _
    ,{0x00, 0x01, 0x02, 0x04, 0x00} // 0x60 `
    ,{0x20, 0x54, 0x54, 0x54, 0x78} // 0x61 a
    ,{0x7f, 0x48, 0x44, 0x44, 0x38} // 0x62 b
    ,{0x38, 0x44, 0x44, 0x44, 0x20} // 0x63 c
    ,{0x38, 0x44, 0x44, 0x48, 0x7f} // 0x64 d
    ,{0x38, 0x54, 0x54, 0x54, 0x18} // 0x65 e
    ,{0x08, 0x7e, 0x09, 0x01, 0x02} // 0x66 f
    ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 0x67 g
    ,{0x7f, 0x08, 0x04, 0x04, 0x78} // 0x68 h
    ,{0x00, 0x44, 0x7d, 0x40, 0x00} // 0x69 i
    ,{0x20, 0x40, 0x44, 0x3d, 0x00} // 0x6a j
    ,{0x7f, 0x10, 0x28, 0x44, 0x00} // 0x6b k
    ,{0x00, 0x41, 0x7f, 0x40, 0x00} // 0x6c l
    ,{0x7c, 0x04, 0x18, 0x04, 0x78} // 0x6d m
    ,{0x7c, 0x08, 0x04, 0x04, 0x78} // 0x6e n
    ,{0x38, 0x44, 0x44, 0x44, 0x38} // 0x6f o
    ,{0x7c, 0x14, 0x14, 0x14, 0x08} // 0x70 p
    ,{0x08, 0x14, 0x14, 0x18, 0x7c} // 0x71 q
    ,{0x7c, 0x08, 0x04, 0x04, 0x08} // 0x72 r
    ,{0x48, 0x54, 0x54, 0x54, 0x20} // 0x73 s
    ,{0x04, 0x3f, 0x44, 0x40, 0x20} // 0x74 t
    ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 0x75 u
    ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 0x76 v
    ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 0x77 w
    ,{0x44, 0x28, 0x10, 0x28, 0x44} // 0x78 x
    ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 0x79 y
    ,{0x44, 0x64, 0x54, 0x4c, 0x44} // 0x7a z
    ,{0x00, 0x08, 0x36, 0x41, 0x00} // 0x7b {
    ,{0x00, 0x00, 0x7f, 0x00, 0x00} // 0x7c |
    ,{0x00, 0x41, 0x36, 0x08, 0x00} // 0x7d }
    ,{0x10, 0x08, 0x08, 0x10, 0x08} // 0x7e ~
    ,{0x78, 0x46, 0x41, 0x46, 0x78} // 0x7f DEL
};

static const uint8_t lcd_settings_default[8] = {
    /* Activate chip (PD == 0), use horizontal addressing (V == 0) and enable
    extended instruction set (H == 1). */
    LCD_FCNST | LCD_FCNST_EXT,
    /* Set the temperature coefficent. */
    LCD_TMPCF | (LCD_TMPCF_MSK & 0x03), // 0x03
    /* Set the bias system. */
    LCD_BIASS | (LCD_BIASS_MSK & 0x04), // 0x04
    /* Set the Vop regster. */
    LCD_VOPST | (LCD_VOPST_MSK & 0x3F), // 0x3F
    /* Return to basic instruction set. */
    LCD_FCNST,
    /* Set display mode to normal. */
    LCD_DISPC | LCD_DISPC_NRM,
    /* Set RAM Y address to 0. */
    LCD_ADDRY | (LCD_ADDRY_MSK & 0x00),
    /* Set RAM X address to 0. */
    LCD_ADDRX | (LCD_ADDRX_MSK & 0x00)
};


static uint8_t frame[LCD_FRAME_LENGTH];


void lcd_write_byte(enum LCD_MODE mode, uint8_t byte);
void lcd_write_bytes(enum LCD_MODE mode, const uint8_t *bytes, uint32_t len);


void lcd_init(void) {
    LL_GPIO_InitTypeDef init_struct_gpio;
    LL_SPI_InitTypeDef init_struct_spi;

    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);

    LL_GPIO_StructInit(&init_struct_gpio);
    init_struct_gpio.Mode       = LL_GPIO_MODE_OUTPUT;
    init_struct_gpio.Pin        = LCD_PIN_MODE | LCD_PIN_RST;
    LL_GPIO_Init(LCD_PORT, &init_struct_gpio);

    init_struct_gpio.Alternate  = LL_GPIO_AF_5;
    init_struct_gpio.Mode       = LL_GPIO_MODE_ALTERNATE;
    init_struct_gpio.Pin        = LCD_PIN_CS | LCD_PIN_SCLK | LCD_PIN_MISO | LCD_PIN_MOSI;
    init_struct_gpio.Speed      = LL_GPIO_SPEED_FREQ_HIGH;
    LL_GPIO_Init(LCD_PORT, &init_struct_gpio);

    LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SPI1);

    LL_SPI_StructInit(&init_struct_spi);
    init_struct_spi.BaudRate          = LL_SPI_BAUDRATEPRESCALER_DIV32;
    init_struct_spi.BitOrder          = LL_SPI_MSB_FIRST;
    init_struct_spi.ClockPhase        = LL_SPI_PHASE_2EDGE;
    init_struct_spi.ClockPolarity     = LL_SPI_POLARITY_LOW;
    init_struct_spi.Mode              = LL_SPI_MODE_MASTER;
    init_struct_spi.NSS               = LL_SPI_NSS_HARD_OUTPUT;
    init_struct_spi.TransferDirection = LL_SPI_FULL_DUPLEX;
    LL_SPI_Init(SPI1, &init_struct_spi);

    LL_GPIO_ResetOutputPin(LCD_PORT, LCD_PIN_RST);
    LL_mDelay(10);
    LL_GPIO_SetOutputPin(LCD_PORT, LCD_PIN_RST);
    LL_mDelay(10);

    lcd_write_bytes(LCD_MODE_CMD, lcd_settings_default, 8);

    lcd_update();
}

void lcd_update(void) {
    lcd_set_cursor(0, 0);
    lcd_write_bytes(LCD_MODE_DATA, frame, LCD_FRAME_LENGTH);
}

void lcd_clear(void) {
    uint32_t i;
    for(i = 0; i < LCD_FRAME_LENGTH; i++) {
        frame[i] = 0x00;
    }
}

void lcd_set(void) {
    uint32_t i;
    for(i = 0; i < LCD_FRAME_LENGTH; i++) {
        frame[i] = 0xFF;
    }
}

void lcd_set_cursor(uint8_t x, uint8_t y) {
    lcd_write_byte(LCD_MODE_CMD, LCD_FCNST); // Use basic extended instructions
    lcd_write_byte(LCD_MODE_CMD, LCD_ADDRX | (LCD_ADDRX_MSK & x));
    lcd_write_byte(LCD_MODE_CMD, LCD_ADDRY | (LCD_ADDRY_MSK & y));
}

void lcd_print(char *string, uint32_t len) {
    uint32_t c, i, j, k;
    i = 0;
    for(j = 0; j < len; j++) {
        frame[i++] = 0x00;
        i %= LCD_FRAME_LENGTH;

        c = (string[j] - 0x20) % 96;
        for(k = 0; k < 5; k++) {
            frame[i++] = charset[c][k];
            i %= LCD_FRAME_LENGTH;
        }

        frame[i++] = 0x00;
        i %= LCD_FRAME_LENGTH;
    }
}

void lcd_print_c(uint8_t c) {
    uint8_t i;

    c = (c - 0x20) % 96;

    lcd_write_byte(LCD_MODE_DATA, 0x00);

    for(i = 0; i < 5; i++) {
        lcd_write_byte(LCD_MODE_DATA, charset[c][i]);
    }

    lcd_write_byte(LCD_MODE_DATA, 0x00);
}

void lcd_write_byte(enum LCD_MODE mode, uint8_t byte) {
    if(mode == LCD_MODE_CMD) {
        LL_GPIO_ResetOutputPin(LCD_PORT, LCD_PIN_MODE);
    } else if(mode == LCD_MODE_DATA) {
        LL_GPIO_SetOutputPin(LCD_PORT, LCD_PIN_MODE);
    }

    LL_SPI_Enable(SPI1);
    LL_SPI_TransmitData8(SPI1, byte);
    while(!LL_SPI_IsActiveFlag_TXE(SPI1));
    LL_SPI_Disable(SPI1);
}

void lcd_write_bytes(enum LCD_MODE mode, const uint8_t *bytes, uint32_t len) {
    uint32_t i;

    if(mode == LCD_MODE_CMD) {
        LL_GPIO_ResetOutputPin(LCD_PORT, LCD_PIN_MODE);
    } else if(mode == LCD_MODE_DATA) {
        LL_GPIO_SetOutputPin(LCD_PORT, LCD_PIN_MODE);
    }

    LL_SPI_Enable(SPI1);
    for(i = 0; i < len; i++) {
        if(mode == LCD_MODE_CMD) {
            LL_SPI_TransmitData8(SPI1, bytes[i]);
        } else if(mode == LCD_MODE_DATA) {
            LL_SPI_TransmitData8(SPI1, byte_reverse[bytes[len-i-1]]);
            //LL_SPI_TransmitData8(SPI1, bytes[len-i-1]);
        }
        while(!LL_SPI_IsActiveFlag_TXE(SPI1));
    }
    LL_SPI_Disable(SPI1);
}

void lcd_test(void) {
    LL_GPIO_SetOutputPin(LCD_PORT, LCD_PIN_MODE);
    LL_SPI_Enable(SPI1);
    LL_SPI_TransmitData8(SPI1, 0x08);
    while(!LL_SPI_IsActiveFlag_TXE(SPI1));
    LL_SPI_TransmitData8(SPI1, 0x14);
    while(!LL_SPI_IsActiveFlag_TXE(SPI1));
    LL_SPI_TransmitData8(SPI1, 0x22);
    while(!LL_SPI_IsActiveFlag_TXE(SPI1));
    LL_SPI_TransmitData8(SPI1, 0x41);
    while(!LL_SPI_IsActiveFlag_TXE(SPI1));
    LL_SPI_TransmitData8(SPI1, 0x00);
    while(!LL_SPI_IsActiveFlag_TXE(SPI1));
    LL_SPI_Disable(SPI1);
}
